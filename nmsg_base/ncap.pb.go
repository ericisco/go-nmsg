// Code generated by protoc-gen-go.
// source: ncap.proto
// DO NOT EDIT!

package nmsg_base

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type NcapType int32

const (
	NcapType_IPV4   NcapType = 0
	NcapType_IPV6   NcapType = 1
	NcapType_Legacy NcapType = 2
)

var NcapType_name = map[int32]string{
	0: "IPV4",
	1: "IPV6",
	2: "Legacy",
}
var NcapType_value = map[string]int32{
	"IPV4":   0,
	"IPV6":   1,
	"Legacy": 2,
}

func (x NcapType) Enum() *NcapType {
	p := new(NcapType)
	*p = x
	return p
}
func (x NcapType) String() string {
	return proto.EnumName(NcapType_name, int32(x))
}
func (x *NcapType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NcapType_value, data, "NcapType")
	if err != nil {
		return err
	}
	*x = NcapType(value)
	return nil
}
func (NcapType) EnumDescriptor() ([]byte, []int) { return fileDescriptor8, []int{0} }

type NcapLegacyType int32

const (
	NcapLegacyType_Ncap_UDP  NcapLegacyType = 0
	NcapLegacyType_Ncap_TCP  NcapLegacyType = 1
	NcapLegacyType_Ncap_ICMP NcapLegacyType = 2
)

var NcapLegacyType_name = map[int32]string{
	0: "Ncap_UDP",
	1: "Ncap_TCP",
	2: "Ncap_ICMP",
}
var NcapLegacyType_value = map[string]int32{
	"Ncap_UDP":  0,
	"Ncap_TCP":  1,
	"Ncap_ICMP": 2,
}

func (x NcapLegacyType) Enum() *NcapLegacyType {
	p := new(NcapLegacyType)
	*p = x
	return p
}
func (x NcapLegacyType) String() string {
	return proto.EnumName(NcapLegacyType_name, int32(x))
}
func (x *NcapLegacyType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NcapLegacyType_value, data, "NcapLegacyType")
	if err != nil {
		return err
	}
	*x = NcapLegacyType(value)
	return nil
}
func (NcapLegacyType) EnumDescriptor() ([]byte, []int) { return fileDescriptor8, []int{1} }

type Ncap struct {
	Type    *NcapType `protobuf:"varint,1,req,name=type,enum=nmsg.base.NcapType" json:"type,omitempty"`
	Payload []byte    `protobuf:"bytes,2,req,name=payload" json:"payload,omitempty"`
	// legacy NCAP fields
	Ltype            *NcapLegacyType `protobuf:"varint,3,opt,name=ltype,enum=nmsg.base.NcapLegacyType" json:"ltype,omitempty"`
	Srcip            []byte          `protobuf:"bytes,4,opt,name=srcip" json:"srcip,omitempty"`
	Dstip            []byte          `protobuf:"bytes,5,opt,name=dstip" json:"dstip,omitempty"`
	Lint0            *uint32         `protobuf:"varint,6,opt,name=lint0" json:"lint0,omitempty"`
	Lint1            *uint32         `protobuf:"varint,7,opt,name=lint1" json:"lint1,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Ncap) Reset()                    { *m = Ncap{} }
func (m *Ncap) String() string            { return proto.CompactTextString(m) }
func (*Ncap) ProtoMessage()               {}
func (*Ncap) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{0} }

func (m *Ncap) GetType() NcapType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return NcapType_IPV4
}

func (m *Ncap) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Ncap) GetLtype() NcapLegacyType {
	if m != nil && m.Ltype != nil {
		return *m.Ltype
	}
	return NcapLegacyType_Ncap_UDP
}

func (m *Ncap) GetSrcip() []byte {
	if m != nil {
		return m.Srcip
	}
	return nil
}

func (m *Ncap) GetDstip() []byte {
	if m != nil {
		return m.Dstip
	}
	return nil
}

func (m *Ncap) GetLint0() uint32 {
	if m != nil && m.Lint0 != nil {
		return *m.Lint0
	}
	return 0
}

func (m *Ncap) GetLint1() uint32 {
	if m != nil && m.Lint1 != nil {
		return *m.Lint1
	}
	return 0
}

func init() {
	proto.RegisterType((*Ncap)(nil), "nmsg.base.Ncap")
	proto.RegisterEnum("nmsg.base.NcapType", NcapType_name, NcapType_value)
	proto.RegisterEnum("nmsg.base.NcapLegacyType", NcapLegacyType_name, NcapLegacyType_value)
}

func init() { proto.RegisterFile("ncap.proto", fileDescriptor8) }

var fileDescriptor8 = []byte{
	// 218 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xe2, 0xe2, 0xca, 0x4b, 0x4e, 0x2c,
	0xd0, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0xcc, 0xcb, 0x2d, 0x4e, 0xd7, 0x4b, 0x4a, 0x2c,
	0x4e, 0x55, 0x5a, 0xc0, 0xc8, 0xc5, 0xe2, 0x07, 0x94, 0x11, 0x52, 0xe4, 0x62, 0x29, 0xa9, 0x2c,
	0x48, 0x95, 0x60, 0x54, 0x60, 0xd2, 0xe0, 0x33, 0x12, 0xd6, 0x83, 0x2b, 0xd1, 0x03, 0x49, 0x87,
	0x00, 0xa5, 0x84, 0xf8, 0xb9, 0xd8, 0x0b, 0x12, 0x2b, 0x73, 0xf2, 0x13, 0x53, 0x24, 0x98, 0x80,
	0xaa, 0x78, 0x84, 0x34, 0xb8, 0x58, 0x73, 0xc0, 0x9a, 0x98, 0x15, 0x18, 0x81, 0x9a, 0x24, 0xd1,
	0x34, 0xf9, 0xa4, 0xa6, 0x27, 0x26, 0x57, 0x82, 0xb5, 0xf2, 0x72, 0xb1, 0x16, 0x17, 0x25, 0x67,
	0x16, 0x48, 0xb0, 0x00, 0x55, 0xf2, 0x80, 0xb8, 0x29, 0xc5, 0x25, 0x40, 0x2e, 0x2b, 0x8c, 0x9b,
	0x93, 0x99, 0x57, 0x62, 0x20, 0xc1, 0x06, 0xe4, 0xf2, 0xc2, 0xb8, 0x86, 0x12, 0xec, 0x20, 0xae,
	0x96, 0x16, 0x17, 0x07, 0xdc, 0x09, 0x1c, 0x5c, 0x2c, 0x9e, 0x01, 0x61, 0x26, 0x02, 0x0c, 0x50,
	0x96, 0x99, 0x00, 0xa3, 0x10, 0x17, 0x17, 0x1b, 0xc4, 0x26, 0x01, 0x26, 0x2d, 0x6b, 0x2e, 0x3e,
	0x34, 0x9b, 0x79, 0x20, 0xba, 0xe3, 0x43, 0x5d, 0x02, 0x80, 0xba, 0x60, 0xbc, 0x10, 0xe7, 0x00,
	0xa0, 0x4e, 0x5e, 0x2e, 0x4e, 0x30, 0xcf, 0xd3, 0xd9, 0x37, 0x40, 0x80, 0x09, 0x10, 0x00, 0x00,
	0xff, 0xff, 0x36, 0x82, 0xd0, 0xf3, 0x23, 0x01, 0x00, 0x00,
}
